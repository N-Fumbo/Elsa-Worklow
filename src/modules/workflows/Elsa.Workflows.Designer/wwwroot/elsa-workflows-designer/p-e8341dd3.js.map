{"version":3,"names":["ActivityNodeClass","constructor","activity","this","parents","children","nodeId","ancestorIds","ancestors","reverse","map","x","id","length","join","_activity","value","_parents","_children","descendants","list","child","push","parent","siblings","flatMap","siblingsAndCousins","createActivityLookup","nodes","node","createActivityNodeMap","walkActivities","root","descriptors","descriptorsStore","activityDescriptors","collectedActivities","Set","graph","collectedNodes","walkRecursive","flatten","flattenList","activities","childList","ports","getPorts","port","collectedNodesArray","Array","from","childNode","find","has","add","includes","portProviderRegistry","Container","get","PortProviderRegistry","portProvider","type","activityDescriptor","typeName","getOutboundPorts","activityPorts","portProviderContext","resolvePort","name","isArray"],"sources":["./src/services/activity-walker.ts"],"sourcesContent":["import 'reflect-metadata';\nimport {camelCase} from 'lodash';\nimport {Container} from \"typedi\"\nimport {Activity, ActivityDescriptor} from \"../models\";\nimport {PortProviderRegistry} from \"./port-provider-registry\";\nimport descriptorsStore from '../data/descriptors-store';\nimport {Hash} from \"../utils\";\nimport {PortProviderContext} from \"./port-provider\";\n\nexport interface ActivityNode {\n  activity: Activity;\n  parents: Array<ActivityNode>;\n  children: Array<ActivityNode>;\n  port?: string;\n  nodeId: string;\n\n  descendants(): Array<ActivityNode>;\n\n  ancestors(): Array<ActivityNode>;\n\n  siblings(): Array<ActivityNode>;\n\n  siblingsAndCousins(): Array<ActivityNode>;\n}\n\nexport interface ActivityPort {\n  activity: Activity;\n  port: string;\n}\n\nexport class ActivityNodeClass implements ActivityNode {\n  private _activity: Activity;\n  private _parents: Array<ActivityNode>;\n  private _children: Array<ActivityNode>;\n\n  constructor(activity) {\n    this.activity = activity;\n    this.parents = [];\n    this.children = [];\n  }\n\n  get nodeId() {\n    const ancestorIds = [...this.ancestors()].reverse().map(x => x.activity.id);\n    return ancestorIds.length ? `${ancestorIds.join(\":\")}:${this.activity.id}` : this.activity.id;\n  }\n\n  get activity() {\n    return this._activity;\n  }\n\n  set activity(value) {\n    this._activity = value;\n  }\n\n  get parents() {\n    return this._parents;\n  }\n\n  set parents(value) {\n    this._parents = value;\n  }\n\n  get children() {\n    return this._children;\n  }\n\n  set children(value) {\n    this._children = value;\n  }\n\n  descendants() {\n    const list = [];\n\n    for (let child of this.children) {\n      list.push(child);\n      list.push(...child.descendants());\n    }\n\n    return list;\n  }\n\n  ancestors() {\n    const list = [];\n\n    for (let parent of this.parents) {\n      list.push(parent);\n      list.push(...parent.ancestors());\n    }\n\n    return list;\n  }\n\n  siblings() {\n    return this.parents.flatMap(parent => parent.children);\n  }\n\n  siblingsAndCousins() {\n    return this.parents.flatMap(parent => parent.descendants().flatMap(x => x.children));\n  }\n}\n\n\nexport function createActivityLookup(nodes: Array<ActivityNode>): Hash<Activity> {\n  const map = {};\n\n  for (const node of nodes)\n    map[node.activity.id] = node.activity;\n\n  return map;\n}\n\nexport function createActivityNodeMap(nodes: Array<ActivityNode>): Hash<ActivityNode> {\n  const map = {};\n\n  for (const node of nodes)\n    map[node.activity.id] = node;\n\n  return map;\n}\n\nexport function walkActivities(root: Activity): ActivityNode {\n  const descriptors = descriptorsStore.activityDescriptors;\n  const collectedActivities = new Set<Activity>([root]);\n  const graph: ActivityNode = new ActivityNodeClass(root);\n  const collectedNodes = new Set<ActivityNode>([graph]);\n\n  walkRecursive(graph, root, collectedActivities, collectedNodes, descriptors);\n  return graph;\n}\n\nexport function flatten(root: ActivityNode): Array<ActivityNode> {\n  return flattenList([root]);\n}\n\nexport function flattenList(activities: Array<ActivityNode>): Array<ActivityNode> {\n  let list: Array<ActivityNode> = [...activities];\n\n  for (const activity of activities) {\n    const childList = flattenList(activity.children);\n    list = [...list, ...childList];\n  }\n\n  return list;\n}\n\nfunction walkRecursive(node: ActivityNode, activity: Activity, collectedActivities: Set<Activity>, collectedNodes: Set<ActivityNode>, descriptors: Array<ActivityDescriptor>) {\n  const ports = getPorts(node, activity, descriptors);\n\n  for (const port of ports) {\n    const collectedNodesArray = Array.from(collectedNodes);\n    let childNode = collectedNodesArray.find(x => x.activity == port.activity);\n\n    if (!childNode) {\n      childNode = new ActivityNodeClass(port.activity);\n      childNode.port = port.port;\n      //childNode = {activity: port.activity, children: [], parents: [], port: port.port};\n\n      if (!collectedNodes.has(childNode))\n        collectedNodes.add(childNode);\n    }\n\n    if (childNode !== node) {\n      if (!!childNode.activity) {\n        if (!childNode.parents.includes(node))\n          childNode.parents.push(node);\n\n        if (!node.children.includes(childNode))\n          node.children.push(childNode);\n\n        if (!collectedActivities.has(port.activity))\n          collectedActivities.add(port.activity);\n\n        walkRecursive(childNode, port.activity, collectedActivities, collectedNodes, descriptors);\n      }\n    }\n  }\n}\n\nfunction getPorts(node: ActivityNode, activity: Activity, descriptors: Array<ActivityDescriptor>): Array<ActivityPort> {\n  const portProviderRegistry = Container.get(PortProviderRegistry);\n  const portProvider = portProviderRegistry.get(activity.type);\n  const activityDescriptor = descriptors.find(x => x.typeName == activity.type);\n  const ports = portProvider.getOutboundPorts({activity, activityDescriptor});\n  let activityPorts: Array<ActivityPort> = [];\n\n  const portProviderContext: PortProviderContext = {\n    activityDescriptor,\n    activity\n  };\n\n  for (const port of ports) {\n    const value = portProvider.resolvePort(port.name, portProviderContext);\n\n    if (Array.isArray(value)) {\n      const activities = value as Array<Activity>;\n      activityPorts = [...activityPorts, ...activities.map(x => ({port: port.name, activity: x}))];\n    } else {\n      activityPorts.push({port: port.name, activity: value});\n    }\n  }\n\n  return activityPorts;\n}\n"],"mappings":"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"}